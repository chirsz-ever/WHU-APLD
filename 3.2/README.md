# 象棋中马的遍历

## 题目

### 【问题描述】
在N\*N棋盘上，任意一个位置放置一个棋子马，要能选择一套合适的移动路线，按象棋中“马走日”的移动规则不重复地遍历棋盘上每一个位置点。

### 【基本要求】
1. 起始位置坐标由用户输入任意指定，然后依次输出所遍历的每个位置坐标。
2. 开始先不必考虑象棋中“蹩马腿”的规则，实现基本遍历功能。
3. 棋谱的大小N（N>5）自行设定，注意事先分析算法的时间复杂度。

### 【扩展要求】
1. 有兴趣的同学可在棋盘上设置一个或多个憋马腿的棋子，尝试遍历过程如何完善。

### 【实现提示】
1. 从图的遍历角度思考解决途径
2. 马可以移动的点位置变化关系为：
```c
int fx[8]={1,2,2,1,-1,-2,-2,-1};
int fy[8]={2,1,-1,-2,-2,-1,1,2};
```

## 代码描述
实验代码使用C++写成，使用了图形库[EGE](https://xege.org)和界面库[microui](https://github.com/rxi/microui)。
本程序使用图形化界面，可通过命令行参数输入棋盘行列数，通过鼠标点选放置“马”棋子和障碍棋子。程序定义了GameContex类，并用其对象存储程序状态和控制程序流程。GUI显示和程序流程推进都采用了状态机的方式。
搜索路径使用的是深度优先搜索，并且使用了贪心策略，每次选择下一步探索的位置时选择出口数较少的位置，这样可以较快找到一条可行路径。

搜索路径被单独放置在一个线程中，这样可以避免算法运行过程中程序失去响应，可以在长时间未算出结果时关闭窗口。


## 编译方法
在当前目录下执行

```bash
$ make
```
编译完成后将在`bin`子目录下生成可执行文件`horse`。

建议使用TDM-GCC64或者用Qt Maintenance Tool安装的64位mingw编译，默认的mingw 8.2不带iconv库和pthread库。

## 运行方式
直接运行`horse`程序，会打开一个绘制了8×8大小棋盘的窗口并让你点选“马”棋子的起始位置，选好后点击“下一步”继续点选障碍棋子（可选0个，1个或更多个，在已经选择的棋子上再点一下可取消选择），选择完毕后点击“开始寻找路径”以启动寻路，找到可行路径后将会绘制到棋盘上。

运行`horse`程序时可加上命令行参数控制棋盘大小，格式是
```bash
$ horse M N
```
M，N为正整数，效果是绘制M行N列的棋盘。要求M和N都要大于2且至少有一个大于4。
